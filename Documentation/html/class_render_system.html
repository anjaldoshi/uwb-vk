<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>UWB-VK: RenderSystem Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">UWB-VK
   </div>
   <div id="projectbrief">UWB MSCSSE Capstone Project</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_render_system.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_render_system-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RenderSystem Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Primary class responsible for rendering operations.  
 <a href="class_render_system.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_render_system_8h_source.html">RenderSystem.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a20496a8f52c4eb755d4bfcaba2e98e1c"><td class="memItemLeft" align="right" valign="top"><a id="a20496a8f52c4eb755d4bfcaba2e98e1c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a20496a8f52c4eb755d4bfcaba2e98e1c">RenderSystem</a> ()</td></tr>
<tr class="memdesc:a20496a8f52c4eb755d4bfcaba2e98e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a20496a8f52c4eb755d4bfcaba2e98e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d0d7ba3d8c56cb089cb7b6609c5cac"><td class="memItemLeft" align="right" valign="top"><a id="aa4d0d7ba3d8c56cb089cb7b6609c5cac"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#aa4d0d7ba3d8c56cb089cb7b6609c5cac">initialize</a> (GLFWwindow *window, const std::string &amp;appName)</td></tr>
<tr class="memdesc:aa4d0d7ba3d8c56cb089cb7b6609c5cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the <a class="el" href="class_render_system.html" title="Primary class responsible for rendering operations.">RenderSystem</a>. <br /></td></tr>
<tr class="separator:aa4d0d7ba3d8c56cb089cb7b6609c5cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc6523a059eacee7fb4dd20657c4713"><td class="memItemLeft" align="right" valign="top"><a id="a4bc6523a059eacee7fb4dd20657c4713"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a4bc6523a059eacee7fb4dd20657c4713">drawFrame</a> ()</td></tr>
<tr class="memdesc:a4bc6523a059eacee7fb4dd20657c4713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a single frame. <br /></td></tr>
<tr class="separator:a4bc6523a059eacee7fb4dd20657c4713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d20419e00ec4e1bc4cfd77689b575c8"><td class="memItemLeft" align="right" valign="top"><a id="a9d20419e00ec4e1bc4cfd77689b575c8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a9d20419e00ec4e1bc4cfd77689b575c8">cleanup</a> ()</td></tr>
<tr class="memdesc:a9d20419e00ec4e1bc4cfd77689b575c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up all allocated resources. <br /></td></tr>
<tr class="separator:a9d20419e00ec4e1bc4cfd77689b575c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae24ad1ef810abc7a16ca331f4e6eef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#afae24ad1ef810abc7a16ca331f4e6eef">createTexture</a> (std::shared_ptr&lt; <a class="el" href="class_texture.html">Texture</a> &gt; &amp;texture, const std::string &amp;filename)</td></tr>
<tr class="memdesc:afae24ad1ef810abc7a16ca331f4e6eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="class_texture.html" title="A class for holding the information loaded from texture files.">Texture</a> object.  <a href="#afae24ad1ef810abc7a16ca331f4e6eef">More...</a><br /></td></tr>
<tr class="separator:afae24ad1ef810abc7a16ca331f4e6eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16952550c2f754cd60d2a9630f6c1f0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a16952550c2f754cd60d2a9630f6c1f0d">createMesh</a> (std::shared_ptr&lt; <a class="el" href="class_mesh.html">Mesh</a> &gt; &amp;mesh, const std::string &amp;filename, bool calculateTangents)</td></tr>
<tr class="memdesc:a16952550c2f754cd60d2a9630f6c1f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="class_mesh.html" title="A Mesh composed of vertex and index buffers.">Mesh</a> object.  <a href="#a16952550c2f754cd60d2a9630f6c1f0d">More...</a><br /></td></tr>
<tr class="separator:a16952550c2f754cd60d2a9630f6c1f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0558495d4560e36e338336645f34153"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#ac0558495d4560e36e338336645f34153">createShader</a> (std::shared_ptr&lt; <a class="el" href="class_shader.html">Shader</a> &gt; &amp;shader, const std::string &amp;filename, VkShaderStageFlagBits stage)</td></tr>
<tr class="memdesc:ac0558495d4560e36e338336645f34153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="class_shader.html" title="A Single Shader module and shader stage create info.">Shader</a> object.  <a href="#ac0558495d4560e36e338336645f34153">More...</a><br /></td></tr>
<tr class="separator:ac0558495d4560e36e338336645f34153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90bf882e4c3136ee272a1733eb38291"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#aa90bf882e4c3136ee272a1733eb38291">createRenderable</a> (std::shared_ptr&lt; <a class="el" href="class_renderable.html">Renderable</a> &gt; &amp;renderable)</td></tr>
<tr class="memdesc:aa90bf882e4c3136ee272a1733eb38291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="class_renderable.html" title="A Class for representing objects that are rendered in the scene.">Renderable</a> object.  <a href="#aa90bf882e4c3136ee272a1733eb38291">More...</a><br /></td></tr>
<tr class="separator:aa90bf882e4c3136ee272a1733eb38291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaee982760399e62180207c573a469e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#aeaee982760399e62180207c573a469e7">instantiateRenderable</a> (std::shared_ptr&lt; <a class="el" href="class_renderable.html">Renderable</a> &gt; &amp;renderable)</td></tr>
<tr class="memdesc:aeaee982760399e62180207c573a469e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiate a renderable that has been set up.  <a href="#aeaee982760399e62180207c573a469e7">More...</a><br /></td></tr>
<tr class="separator:aeaee982760399e62180207c573a469e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e41f536fee8a17796034acaeafb6e9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43e41f536fee8a17796034acaeafb6e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_render_system.html#a43e41f536fee8a17796034acaeafb6e9">createUniformBuffer</a> (std::shared_ptr&lt; <a class="el" href="struct_u_b_o.html">UBO</a> &gt; &amp;ubo, const size_t &amp;count)</td></tr>
<tr class="memdesc:a43e41f536fee8a17796034acaeafb6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Uniform Buffer Object.  <a href="#a43e41f536fee8a17796034acaeafb6e9">More...</a><br /></td></tr>
<tr class="separator:a43e41f536fee8a17796034acaeafb6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3025bd7da582aef27ba42bb4f32de9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3c3025bd7da582aef27ba42bb4f32de9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_render_system.html#a3c3025bd7da582aef27ba42bb4f32de9">updateUniformBuffer</a> (const <a class="el" href="struct_u_b_o.html">UBO</a> &amp;ubo, const T &amp;uboData, size_t bufIndex)</td></tr>
<tr class="memdesc:a3c3025bd7da582aef27ba42bb4f32de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the info inside a <a class="el" href="struct_u_b_o.html" title="A Uniform Buffer Object for sending data to shaders.">UBO</a>.  <a href="#a3c3025bd7da582aef27ba42bb4f32de9">More...</a><br /></td></tr>
<tr class="separator:a3c3025bd7da582aef27ba42bb4f32de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3fc11d70c1b8da1178cd6f5f647c74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a3d3fc11d70c1b8da1178cd6f5f647c74">setClearColor</a> (VkClearValue clearColor)</td></tr>
<tr class="memdesc:a3d3fc11d70c1b8da1178cd6f5f647c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the background clear color to a given value.  <a href="#a3d3fc11d70c1b8da1178cd6f5f647c74">More...</a><br /></td></tr>
<tr class="separator:a3d3fc11d70c1b8da1178cd6f5f647c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad31d7e4c0a7b37fd101f3b5c13dbe12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#aad31d7e4c0a7b37fd101f3b5c13dbe12">setLightMVPBuffer</a> (const glm::mat4 &amp;mvp)</td></tr>
<tr class="memdesc:aad31d7e4c0a7b37fd101f3b5c13dbe12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the MVP buffer for a shadow-casting light source.  <a href="#aad31d7e4c0a7b37fd101f3b5c13dbe12">More...</a><br /></td></tr>
<tr class="separator:aad31d7e4c0a7b37fd101f3b5c13dbe12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0624e2d58d21719611ce863eafb031"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_shadow_map.html">ShadowMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a8f0624e2d58d21719611ce863eafb031">getShadowMap</a> () const</td></tr>
<tr class="memdesc:a8f0624e2d58d21719611ce863eafb031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="struct_shadow_map.html" title="A ShadowMap.">ShadowMap</a>.  <a href="#a8f0624e2d58d21719611ce863eafb031">More...</a><br /></td></tr>
<tr class="separator:a8f0624e2d58d21719611ce863eafb031"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aa28dd2f1b27a913f0b972f3194a74618"><td class="memItemLeft" align="right" valign="top"><a id="aa28dd2f1b27a913f0b972f3194a74618"></a>
std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_renderable.html">Renderable</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#aa28dd2f1b27a913f0b972f3194a74618">mRenderables</a></td></tr>
<tr class="memdesc:aa28dd2f1b27a913f0b972f3194a74618"><td class="mdescLeft">&#160;</td><td class="mdescRight">The renderables currently in use and being rendered. <br /></td></tr>
<tr class="separator:aa28dd2f1b27a913f0b972f3194a74618"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a198495772c148ec0fc5319a36721c62b"><td class="memItemLeft" align="right" valign="top"><a id="a198495772c148ec0fc5319a36721c62b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a198495772c148ec0fc5319a36721c62b">createSwapchain</a> ()</td></tr>
<tr class="memdesc:a198495772c148ec0fc5319a36721c62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the <a class="el" href="class_swapchain.html" title="A swapchain of images the Render System draws to the screen with.">Swapchain</a>. <br /></td></tr>
<tr class="separator:a198495772c148ec0fc5319a36721c62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24aff4914313ebaa5d87633d2126b6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#ab24aff4914313ebaa5d87633d2126b6d">recreateSwapchain</a> ()</td></tr>
<tr class="memdesc:ab24aff4914313ebaa5d87633d2126b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recreate the <a class="el" href="class_swapchain.html" title="A swapchain of images the Render System draws to the screen with.">Swapchain</a>.  <a href="#ab24aff4914313ebaa5d87633d2126b6d">More...</a><br /></td></tr>
<tr class="separator:ab24aff4914313ebaa5d87633d2126b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c200cab1427a7555fc5020337268be"><td class="memItemLeft" align="right" valign="top"><a id="a71c200cab1427a7555fc5020337268be"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a71c200cab1427a7555fc5020337268be">cleanupSwapchain</a> ()</td></tr>
<tr class="memdesc:a71c200cab1427a7555fc5020337268be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup Swapchain-related resources. <br /></td></tr>
<tr class="separator:a71c200cab1427a7555fc5020337268be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1ab5e58172135660b534f2de54daee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#abe1ab5e58172135660b534f2de54daee">createPipeline</a> (VkPipeline &amp;pipeline, VkPipelineLayout &amp;pipelineLayout, VkDescriptorSetLayout &amp;descriptorSetLayout, const std::vector&lt; VkPipelineShaderStageCreateInfo &gt; &amp;shaderStages, VkRenderPass &amp;renderPass)</td></tr>
<tr class="memdesc:abe1ab5e58172135660b534f2de54daee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new pipeline.  <a href="#abe1ab5e58172135660b534f2de54daee">More...</a><br /></td></tr>
<tr class="separator:abe1ab5e58172135660b534f2de54daee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4da98602d449e23fefeac3373f44d0c"><td class="memItemLeft" align="right" valign="top"><a id="af4da98602d449e23fefeac3373f44d0c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#af4da98602d449e23fefeac3373f44d0c">createColorRenderPass</a> ()</td></tr>
<tr class="memdesc:af4da98602d449e23fefeac3373f44d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a color renderPass object for the main pass. <br /></td></tr>
<tr class="separator:af4da98602d449e23fefeac3373f44d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8649ff90d42a54b7afe20529ba03525e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a8649ff90d42a54b7afe20529ba03525e">createFramebuffers</a> (VkRenderPass renderPass)</td></tr>
<tr class="memdesc:a8649ff90d42a54b7afe20529ba03525e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create framebuffers to be used by a pipeline.  <a href="#a8649ff90d42a54b7afe20529ba03525e">More...</a><br /></td></tr>
<tr class="separator:a8649ff90d42a54b7afe20529ba03525e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ef71c72260306ef0bfc7700d097bc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a92ef71c72260306ef0bfc7700d097bc9">createDescriptorPool</a> (uint32_t maxSets, uint32_t maxUniformBuffers, uint32_t maxImageSamplers)</td></tr>
<tr class="memdesc:a92ef71c72260306ef0bfc7700d097bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the DescriptorPool.  <a href="#a92ef71c72260306ef0bfc7700d097bc9">More...</a><br /></td></tr>
<tr class="separator:a92ef71c72260306ef0bfc7700d097bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61949d01de7fd18a18014711198c5ccf"><td class="memItemLeft" align="right" valign="top"><a id="a61949d01de7fd18a18014711198c5ccf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a61949d01de7fd18a18014711198c5ccf">createShadowMapDescriptorSetLayout</a> ()</td></tr>
<tr class="memdesc:a61949d01de7fd18a18014711198c5ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a DescriptorSetLayout for the Shadow pass. <br /></td></tr>
<tr class="separator:a61949d01de7fd18a18014711198c5ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c969e8d5ea7d449572c06c89ae0242"><td class="memItemLeft" align="right" valign="top"><a id="a28c969e8d5ea7d449572c06c89ae0242"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a28c969e8d5ea7d449572c06c89ae0242">createShadowMapDescriptorSets</a> ()</td></tr>
<tr class="memdesc:a28c969e8d5ea7d449572c06c89ae0242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the necessary Descriptor Sets to create a shadow map. <br /></td></tr>
<tr class="separator:a28c969e8d5ea7d449572c06c89ae0242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a187b0185af36602204db40533daaf8"><td class="memItemLeft" align="right" valign="top"><a id="a6a187b0185af36602204db40533daaf8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a6a187b0185af36602204db40533daaf8">createCommandBuffers</a> ()</td></tr>
<tr class="memdesc:a6a187b0185af36602204db40533daaf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the primary command buffers for the main pass. <br /></td></tr>
<tr class="separator:a6a187b0185af36602204db40533daaf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e1bc7f9df303cc2ee02a6677a99ebb"><td class="memItemLeft" align="right" valign="top"><a id="ad2e1bc7f9df303cc2ee02a6677a99ebb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#ad2e1bc7f9df303cc2ee02a6677a99ebb">createShadowCommandBuffers</a> ()</td></tr>
<tr class="memdesc:ad2e1bc7f9df303cc2ee02a6677a99ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the primary command buffers for the shadow pass. <br /></td></tr>
<tr class="separator:ad2e1bc7f9df303cc2ee02a6677a99ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b91a5694d7220da53c8826155f6470d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a6b91a5694d7220da53c8826155f6470d">drawRenderable</a> (VkCommandBuffer commandBuffer, std::shared_ptr&lt; <a class="el" href="class_renderable.html">Renderable</a> &gt; model, VkDescriptorSet &amp;descriptorSet)</td></tr>
<tr class="memdesc:a6b91a5694d7220da53c8826155f6470d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a renderable object.  <a href="#a6b91a5694d7220da53c8826155f6470d">More...</a><br /></td></tr>
<tr class="separator:a6b91a5694d7220da53c8826155f6470d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8787f0e229b21cacb8af3437423fed7"><td class="memItemLeft" align="right" valign="top"><a id="ab8787f0e229b21cacb8af3437423fed7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#ab8787f0e229b21cacb8af3437423fed7">createDepthBuffer</a> ()</td></tr>
<tr class="memdesc:ab8787f0e229b21cacb8af3437423fed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a depth buffer. <br /></td></tr>
<tr class="separator:ab8787f0e229b21cacb8af3437423fed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c7581bfbcc743a8ed8106ff44b4998"><td class="memItemLeft" align="right" valign="top"><a id="ae7c7581bfbcc743a8ed8106ff44b4998"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#ae7c7581bfbcc743a8ed8106ff44b4998">createSyncObjects</a> ()</td></tr>
<tr class="memdesc:ae7c7581bfbcc743a8ed8106ff44b4998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create objects necessary to syncronize frame drawing Sync objects ensure that each stage of the <a class="el" href="class_render_system.html#a4bc6523a059eacee7fb4dd20657c4713" title="Draws a single frame.">drawFrame()</a> method operates in order, as calls to vkQueueSubmit and vkQueuePresentKHR are asynchronous. In addition they ensure that draw commands are not submitted to a frame that is still not done presenting. <br /></td></tr>
<tr class="separator:ae7c7581bfbcc743a8ed8106ff44b4998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb2169091433ee0c10ef581b646ac9f"><td class="memItemLeft" align="right" valign="top"><a id="afdb2169091433ee0c10ef581b646ac9f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#afdb2169091433ee0c10ef581b646ac9f">createShadowMap</a> ()</td></tr>
<tr class="memdesc:afdb2169091433ee0c10ef581b646ac9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the <a class="el" href="struct_shadow_map.html" title="A ShadowMap.">ShadowMap</a>, which is simply a depth map that can be used in the next render pass as ImageSampler input. The resources created as part of the <a class="el" href="struct_shadow_map.html" title="A ShadowMap.">ShadowMap</a> are as follows: VkImage VkImageView VkSampler. <br /></td></tr>
<tr class="separator:afdb2169091433ee0c10ef581b646ac9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fd2d41cf272efb8da347375876f709"><td class="memItemLeft" align="right" valign="top"><a id="a45fd2d41cf272efb8da347375876f709"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a45fd2d41cf272efb8da347375876f709">createShadowMapPipeline</a> ()</td></tr>
<tr class="memdesc:a45fd2d41cf272efb8da347375876f709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Pipeline for writing to the <a class="el" href="struct_shadow_map.html" title="A ShadowMap.">ShadowMap</a> The pipeline created is simple, in that it contains only a single vertex shader. <br /></td></tr>
<tr class="separator:a45fd2d41cf272efb8da347375876f709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7bcbc69bc3e34c5cccd42a5a1ddf91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a6c7bcbc69bc3e34c5cccd42a5a1ddf91">createShadowRenderPass</a> (const <a class="el" href="struct_shadow_map.html">ShadowMap</a> &amp;shadowMap)</td></tr>
<tr class="memdesc:a6c7bcbc69bc3e34c5cccd42a5a1ddf91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a RenderPass for writing to the <a class="el" href="struct_shadow_map.html" title="A ShadowMap.">ShadowMap</a>.  <a href="#a6c7bcbc69bc3e34c5cccd42a5a1ddf91">More...</a><br /></td></tr>
<tr class="separator:a6c7bcbc69bc3e34c5cccd42a5a1ddf91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c31fab93f511b2103917679ccc52f6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a6c31fab93f511b2103917679ccc52f6d">createShadowFramebuffers</a> (VkRenderPass shadowRenderPass, VkImageView shadowImageView)</td></tr>
<tr class="memdesc:a6c31fab93f511b2103917679ccc52f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the FrameBuffers used as the output.  <a href="#a6c31fab93f511b2103917679ccc52f6d">More...</a><br /></td></tr>
<tr class="separator:a6c31fab93f511b2103917679ccc52f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a32bbfc62a23026279c8fd600e92687d5"><td class="memItemLeft" align="right" valign="top"><a id="a32bbfc62a23026279c8fd600e92687d5"></a>
std::shared_ptr&lt; <a class="el" href="class_vulkan_context.html">VulkanContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a32bbfc62a23026279c8fd600e92687d5">mContext</a></td></tr>
<tr class="memdesc:a32bbfc62a23026279c8fd600e92687d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Vulkan Context object. <br /></td></tr>
<tr class="separator:a32bbfc62a23026279c8fd600e92687d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5e795a489d64db30d85bc918f7501d"><td class="memItemLeft" align="right" valign="top"><a id="ada5e795a489d64db30d85bc918f7501d"></a>
std::shared_ptr&lt; <a class="el" href="class_command_pool.html">CommandPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#ada5e795a489d64db30d85bc918f7501d">mCommandPool</a></td></tr>
<tr class="memdesc:ada5e795a489d64db30d85bc918f7501d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Command Pool for allocating command buffers. <br /></td></tr>
<tr class="separator:ada5e795a489d64db30d85bc918f7501d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654ffa6fe467272a0a56105d117ed805"><td class="memItemLeft" align="right" valign="top"><a id="a654ffa6fe467272a0a56105d117ed805"></a>
std::shared_ptr&lt; <a class="el" href="class_buffer_manager.html">BufferManager</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a654ffa6fe467272a0a56105d117ed805">mBufferManager</a></td></tr>
<tr class="memdesc:a654ffa6fe467272a0a56105d117ed805"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Buffer Manager for allocating and performing buffer operations. <br /></td></tr>
<tr class="separator:a654ffa6fe467272a0a56105d117ed805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd841a0361635ba888c663805a9d2458"><td class="memItemLeft" align="right" valign="top"><a id="afd841a0361635ba888c663805a9d2458"></a>
std::shared_ptr&lt; <a class="el" href="class_image_manager.html">ImageManager</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#afd841a0361635ba888c663805a9d2458">mImageManager</a></td></tr>
<tr class="memdesc:afd841a0361635ba888c663805a9d2458"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Image Manager for allocation and performing Image operations. <br /></td></tr>
<tr class="separator:afd841a0361635ba888c663805a9d2458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aee130a4efdaab6edcdc05b208c5e28"><td class="memItemLeft" align="right" valign="top"><a id="a2aee130a4efdaab6edcdc05b208c5e28"></a>
std::unique_ptr&lt; <a class="el" href="class_swapchain.html">Swapchain</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a2aee130a4efdaab6edcdc05b208c5e28">mSwapchain</a></td></tr>
<tr class="memdesc:a2aee130a4efdaab6edcdc05b208c5e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Primary <a class="el" href="class_swapchain.html" title="A swapchain of images the Render System draws to the screen with.">Swapchain</a> Object. <br /></td></tr>
<tr class="separator:a2aee130a4efdaab6edcdc05b208c5e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661f131c9df9cd22b54a084bb4176c46"><td class="memItemLeft" align="right" valign="top"><a id="a661f131c9df9cd22b54a084bb4176c46"></a>
std::vector&lt; VkCommandBuffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a661f131c9df9cd22b54a084bb4176c46">mCommandBuffers</a></td></tr>
<tr class="memdesc:a661f131c9df9cd22b54a084bb4176c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Main command buffers in use (same size as the swapchain) <br /></td></tr>
<tr class="separator:a661f131c9df9cd22b54a084bb4176c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7a90af8c55faeafdd36aecf0e1277a"><td class="memItemLeft" align="right" valign="top"><a id="aad7a90af8c55faeafdd36aecf0e1277a"></a>
std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_mesh.html">Mesh</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#aad7a90af8c55faeafdd36aecf0e1277a">mMeshes</a></td></tr>
<tr class="memdesc:aad7a90af8c55faeafdd36aecf0e1277a"><td class="mdescLeft">&#160;</td><td class="mdescRight">All meshes that have been created. <br /></td></tr>
<tr class="separator:aad7a90af8c55faeafdd36aecf0e1277a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04b5ca30a770d24c64ac585044857e6"><td class="memItemLeft" align="right" valign="top"><a id="af04b5ca30a770d24c64ac585044857e6"></a>
std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_shader.html">Shader</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#af04b5ca30a770d24c64ac585044857e6">mShaders</a></td></tr>
<tr class="memdesc:af04b5ca30a770d24c64ac585044857e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">All shader objects that have been created. <br /></td></tr>
<tr class="separator:af04b5ca30a770d24c64ac585044857e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c01a933c74c9f3b19184f1015f20d27"><td class="memItemLeft" align="right" valign="top"><a id="a1c01a933c74c9f3b19184f1015f20d27"></a>
std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_texture.html">Texture</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a1c01a933c74c9f3b19184f1015f20d27">mTextures</a></td></tr>
<tr class="memdesc:a1c01a933c74c9f3b19184f1015f20d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">All texture objects that have been created. <br /></td></tr>
<tr class="separator:a1c01a933c74c9f3b19184f1015f20d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245fe0a2308f6868a3c19d25a6db8646"><td class="memItemLeft" align="right" valign="top"><a id="a245fe0a2308f6868a3c19d25a6db8646"></a>
std::vector&lt; std::shared_ptr&lt; <a class="el" href="struct_u_b_o.html">UBO</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a245fe0a2308f6868a3c19d25a6db8646">mUniformBuffers</a></td></tr>
<tr class="memdesc:a245fe0a2308f6868a3c19d25a6db8646"><td class="mdescLeft">&#160;</td><td class="mdescRight">All UBOs that have been created. <br /></td></tr>
<tr class="separator:a245fe0a2308f6868a3c19d25a6db8646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5871df67881e36f34cf8379669721c03"><td class="memItemLeft" align="right" valign="top"><a id="a5871df67881e36f34cf8379669721c03"></a>
std::vector&lt; VkFramebuffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a5871df67881e36f34cf8379669721c03">mSwapchainFramebuffers</a></td></tr>
<tr class="memdesc:a5871df67881e36f34cf8379669721c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">The framebuffers the pipelines write to. <br /></td></tr>
<tr class="separator:a5871df67881e36f34cf8379669721c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accda78ee2421bda18e46311aa573272d"><td class="memItemLeft" align="right" valign="top"><a id="accda78ee2421bda18e46311aa573272d"></a>
VkRenderPass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#accda78ee2421bda18e46311aa573272d">mColorPass</a></td></tr>
<tr class="memdesc:accda78ee2421bda18e46311aa573272d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Second, standard renderpass. <br /></td></tr>
<tr class="separator:accda78ee2421bda18e46311aa573272d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28ff7c7d5f0f710aafdb4f718e32eb7"><td class="memItemLeft" align="right" valign="top"><a id="ae28ff7c7d5f0f710aafdb4f718e32eb7"></a>
VkRenderPass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#ae28ff7c7d5f0f710aafdb4f718e32eb7">mShadowRenderPass</a></td></tr>
<tr class="memdesc:ae28ff7c7d5f0f710aafdb4f718e32eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first renderpass, creating a shadow map. <br /></td></tr>
<tr class="separator:ae28ff7c7d5f0f710aafdb4f718e32eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be2c2304e936d2ab7f26967aaa5ee47"><td class="memItemLeft" align="right" valign="top"><a id="a5be2c2304e936d2ab7f26967aaa5ee47"></a>
VkDescriptorPool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a5be2c2304e936d2ab7f26967aaa5ee47">mDescriptorPool</a></td></tr>
<tr class="memdesc:a5be2c2304e936d2ab7f26967aaa5ee47"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Descriptor Pool DescriptorSets allocate from. <br /></td></tr>
<tr class="separator:a5be2c2304e936d2ab7f26967aaa5ee47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ca6a17b446f6aeb649f27b0a075c4c"><td class="memItemLeft" align="right" valign="top"><a id="a57ca6a17b446f6aeb649f27b0a075c4c"></a>
VkImage&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a57ca6a17b446f6aeb649f27b0a075c4c">mDepthImage</a></td></tr>
<tr class="memdesc:a57ca6a17b446f6aeb649f27b0a075c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The image the depth buffer writes to. <br /></td></tr>
<tr class="separator:a57ca6a17b446f6aeb649f27b0a075c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15de0abc7ef6ac32a374ced4ca4c640"><td class="memItemLeft" align="right" valign="top"><a id="ac15de0abc7ef6ac32a374ced4ca4c640"></a>
VkFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#ac15de0abc7ef6ac32a374ced4ca4c640">mDepthImageFormat</a></td></tr>
<tr class="memdesc:ac15de0abc7ef6ac32a374ced4ca4c640"><td class="mdescLeft">&#160;</td><td class="mdescRight">The format of the depth buffer. <br /></td></tr>
<tr class="separator:ac15de0abc7ef6ac32a374ced4ca4c640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe7fee3deae55b57e895ab097a4a64b"><td class="memItemLeft" align="right" valign="top"><a id="adfe7fee3deae55b57e895ab097a4a64b"></a>
VkDeviceMemory&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#adfe7fee3deae55b57e895ab097a4a64b">mDepthImageMemory</a></td></tr>
<tr class="memdesc:adfe7fee3deae55b57e895ab097a4a64b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The memory the depth buffer is allocated from. <br /></td></tr>
<tr class="separator:adfe7fee3deae55b57e895ab097a4a64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ef2c844cbe00e4059ea299c709e1e0"><td class="memItemLeft" align="right" valign="top"><a id="a49ef2c844cbe00e4059ea299c709e1e0"></a>
VkImageView&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a49ef2c844cbe00e4059ea299c709e1e0">mDepthImageView</a></td></tr>
<tr class="memdesc:a49ef2c844cbe00e4059ea299c709e1e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A VkImageView to the Depth Buffer image. <br /></td></tr>
<tr class="separator:a49ef2c844cbe00e4059ea299c709e1e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8d71a8ab05c208998a422966ade04a"><td class="memItemLeft" align="right" valign="top"><a id="aad8d71a8ab05c208998a422966ade04a"></a>
<a class="el" href="struct_shadow_map.html">ShadowMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#aad8d71a8ab05c208998a422966ade04a">mShadowMap</a></td></tr>
<tr class="memdesc:aad8d71a8ab05c208998a422966ade04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="struct_shadow_map.html" title="A ShadowMap.">ShadowMap</a> object for the shadow pass. <br /></td></tr>
<tr class="separator:aad8d71a8ab05c208998a422966ade04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4469364daea6a3da34bd5d66d4f605"><td class="memItemLeft" align="right" valign="top"><a id="adf4469364daea6a3da34bd5d66d4f605"></a>
std::vector&lt; VkFramebuffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#adf4469364daea6a3da34bd5d66d4f605">mShadowFramebuffers</a></td></tr>
<tr class="memdesc:adf4469364daea6a3da34bd5d66d4f605"><td class="mdescLeft">&#160;</td><td class="mdescRight">The framebuffers the shadow map's pipeline outputs to. <br /></td></tr>
<tr class="separator:adf4469364daea6a3da34bd5d66d4f605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc913051b690f4bf0630d84051b2473c"><td class="memItemLeft" align="right" valign="top"><a id="adc913051b690f4bf0630d84051b2473c"></a>
VkPipeline&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#adc913051b690f4bf0630d84051b2473c">mShadowMapPipeline</a></td></tr>
<tr class="memdesc:adc913051b690f4bf0630d84051b2473c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pipeline the <a class="el" href="struct_shadow_map.html" title="A ShadowMap.">ShadowMap</a> is processeed in. <br /></td></tr>
<tr class="separator:adc913051b690f4bf0630d84051b2473c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd71a293209144f66f4b7b8b16a0024"><td class="memItemLeft" align="right" valign="top"><a id="a6dd71a293209144f66f4b7b8b16a0024"></a>
VkPipelineLayout&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a6dd71a293209144f66f4b7b8b16a0024">mShadowMapPipelineLayout</a></td></tr>
<tr class="memdesc:a6dd71a293209144f66f4b7b8b16a0024"><td class="mdescLeft">&#160;</td><td class="mdescRight">The layout of the <a class="el" href="struct_shadow_map.html" title="A ShadowMap.">ShadowMap</a>'s pipeline. <br /></td></tr>
<tr class="separator:a6dd71a293209144f66f4b7b8b16a0024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2e765044f2fb4cd1ffd9c7b0696bde"><td class="memItemLeft" align="right" valign="top"><a id="aee2e765044f2fb4cd1ffd9c7b0696bde"></a>
<a class="el" href="struct_shader_set.html">ShaderSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#aee2e765044f2fb4cd1ffd9c7b0696bde">mShadowMapShaderSet</a></td></tr>
<tr class="memdesc:aee2e765044f2fb4cd1ffd9c7b0696bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Shaders used in the Shadow Pass (just one vertex shader) <br /></td></tr>
<tr class="separator:aee2e765044f2fb4cd1ffd9c7b0696bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ec85f7bd1a226089ba8b6208d4981f"><td class="memItemLeft" align="right" valign="top"><a id="a39ec85f7bd1a226089ba8b6208d4981f"></a>
VkDescriptorSetLayout&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a39ec85f7bd1a226089ba8b6208d4981f">mShadowMapDescriptorSetLayout</a></td></tr>
<tr class="memdesc:a39ec85f7bd1a226089ba8b6208d4981f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The DescriptorSetLayout for the <a class="el" href="struct_shadow_map.html" title="A ShadowMap.">ShadowMap</a> pipeline. <br /></td></tr>
<tr class="separator:a39ec85f7bd1a226089ba8b6208d4981f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530a3caa22c225ba859a7398314c0e5e"><td class="memItemLeft" align="right" valign="top"><a id="a530a3caa22c225ba859a7398314c0e5e"></a>
std::vector&lt; VkDescriptorSet &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a530a3caa22c225ba859a7398314c0e5e">mShadowMapDescriptorSets</a></td></tr>
<tr class="memdesc:a530a3caa22c225ba859a7398314c0e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The DescriptorSets for all the resources sent to the Shaders processing the <a class="el" href="struct_shadow_map.html" title="A ShadowMap.">ShadowMap</a>. <br /></td></tr>
<tr class="separator:a530a3caa22c225ba859a7398314c0e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4d1f392fc478f4ef7b02937b09a035"><td class="memItemLeft" align="right" valign="top"><a id="aed4d1f392fc478f4ef7b02937b09a035"></a>
std::shared_ptr&lt; <a class="el" href="struct_u_b_o.html">UBO</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#aed4d1f392fc478f4ef7b02937b09a035">mShadowCasterUBO</a></td></tr>
<tr class="memdesc:aed4d1f392fc478f4ef7b02937b09a035"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="struct_u_b_o.html" title="A Uniform Buffer Object for sending data to shaders.">UBO</a> for holding the mvp matrices for the shadow-casting object. <br /></td></tr>
<tr class="separator:aed4d1f392fc478f4ef7b02937b09a035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57e2b9702c90f2b27324ffbcc20e4fe"><td class="memItemLeft" align="right" valign="top"><a id="aa57e2b9702c90f2b27324ffbcc20e4fe"></a>
std::vector&lt; VkCommandBuffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#aa57e2b9702c90f2b27324ffbcc20e4fe">mShadowCommandBuffers</a></td></tr>
<tr class="memdesc:aa57e2b9702c90f2b27324ffbcc20e4fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command Buffers for processing the <a class="el" href="struct_shadow_map.html" title="A ShadowMap.">ShadowMap</a>. <br /></td></tr>
<tr class="separator:aa57e2b9702c90f2b27324ffbcc20e4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8bf79f6f6de8fab7126a4a02f8afa20"><td class="memItemLeft" align="right" valign="top"><a id="ab8bf79f6f6de8fab7126a4a02f8afa20"></a>
std::vector&lt; VkSemaphore &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#ab8bf79f6f6de8fab7126a4a02f8afa20">mImageAvailableSemaphores</a></td></tr>
<tr class="memdesc:ab8bf79f6f6de8fab7126a4a02f8afa20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semaphores for indicating that a new image on the swapchain is available. <br /></td></tr>
<tr class="separator:ab8bf79f6f6de8fab7126a4a02f8afa20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43f42732cf10c16e8b5f54c793758fb"><td class="memItemLeft" align="right" valign="top"><a id="ab43f42732cf10c16e8b5f54c793758fb"></a>
std::vector&lt; VkSemaphore &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#ab43f42732cf10c16e8b5f54c793758fb">mShadowMapAvailableSemaphores</a></td></tr>
<tr class="memdesc:ab43f42732cf10c16e8b5f54c793758fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semaphores for indicating that a new <a class="el" href="struct_shadow_map.html" title="A ShadowMap.">ShadowMap</a> has been created. <br /></td></tr>
<tr class="separator:ab43f42732cf10c16e8b5f54c793758fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54f53003fcabea0932fcb5b859ec4b5"><td class="memItemLeft" align="right" valign="top"><a id="ae54f53003fcabea0932fcb5b859ec4b5"></a>
std::vector&lt; VkSemaphore &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#ae54f53003fcabea0932fcb5b859ec4b5">mRenderFinishedSemaphores</a></td></tr>
<tr class="memdesc:ae54f53003fcabea0932fcb5b859ec4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semaphores for indicating that a new frame has finished rendering. <br /></td></tr>
<tr class="separator:ae54f53003fcabea0932fcb5b859ec4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae483ee5eca6f400b08b0cf4ff295a5"><td class="memItemLeft" align="right" valign="top"><a id="a2ae483ee5eca6f400b08b0cf4ff295a5"></a>
std::vector&lt; VkFence &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#a2ae483ee5eca6f400b08b0cf4ff295a5">mFrameFences</a></td></tr>
<tr class="memdesc:a2ae483ee5eca6f400b08b0cf4ff295a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fences that ensure a frame does not start being drawn until the last frame with the same index is done. <br /></td></tr>
<tr class="separator:a2ae483ee5eca6f400b08b0cf4ff295a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8699ab15bb365a8ba30f398644e08b"><td class="memItemLeft" align="right" valign="top"><a id="ade8699ab15bb365a8ba30f398644e08b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#ade8699ab15bb365a8ba30f398644e08b">mCurrentFrame</a> = 0</td></tr>
<tr class="memdesc:ade8699ab15bb365a8ba30f398644e08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current frame that is being drawn (index into the framebuffer array. <br /></td></tr>
<tr class="separator:ade8699ab15bb365a8ba30f398644e08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27ef13631dad64e0036a2d6b1aab9cf"><td class="memItemLeft" align="right" valign="top"><a id="ac27ef13631dad64e0036a2d6b1aab9cf"></a>
VkClearValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_render_system.html#ac27ef13631dad64e0036a2d6b1aab9cf">mClearColor</a> = { 0.0f, 0.0f, 0.0f, 1.0f }</td></tr>
<tr class="memdesc:ac27ef13631dad64e0036a2d6b1aab9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The color that the screen will be cleared to. <br /></td></tr>
<tr class="separator:ac27ef13631dad64e0036a2d6b1aab9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Primary class responsible for rendering operations. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a92ef71c72260306ef0bfc7700d097bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ef71c72260306ef0bfc7700d097bc9">&#9670;&nbsp;</a></span>createDescriptorPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RenderSystem::createDescriptorPool </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxSets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxUniformBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxImageSamplers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the DescriptorPool. </p>
<p>The Descriptor Pool is memory pool for allocating DescriptorSets from.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxSets</td><td>The maximum number of descriptor sets in the application </td></tr>
    <tr><td class="paramname">maxUniformBuffers</td><td>The maximum number of UBOs that will be used </td></tr>
    <tr><td class="paramname">maxImageSamplers</td><td>The maximum number of Image/Samplers(i.e. Textures) in the application. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8649ff90d42a54b7afe20529ba03525e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8649ff90d42a54b7afe20529ba03525e">&#9670;&nbsp;</a></span>createFramebuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RenderSystem::createFramebuffers </td>
          <td>(</td>
          <td class="paramtype">VkRenderPass&#160;</td>
          <td class="paramname"><em>renderPass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create framebuffers to be used by a pipeline. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderPass</td><td>The renderpass that will write to the framebuffers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16952550c2f754cd60d2a9630f6c1f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16952550c2f754cd60d2a9630f6c1f0d">&#9670;&nbsp;</a></span>createMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RenderSystem::createMesh </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_mesh.html">Mesh</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>calculateTangents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="class_mesh.html" title="A Mesh composed of vertex and index buffers.">Mesh</a> object. </p>
<p>Creates a <a class="el" href="class_mesh.html" title="A Mesh composed of vertex and index buffers.">Mesh</a> object with std::make_shared and keeps a copy to properly cleanup at the end</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The mesh object to create </td></tr>
    <tr><td class="paramname">filename</td><td>The file to create the mesh from (must be a *.mesh file) </td></tr>
    <tr><td class="paramname">calculateTangents</td><td>Whether to calculate tangents for all of the vertices (used for normal mapping) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe1ab5e58172135660b534f2de54daee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1ab5e58172135660b534f2de54daee">&#9670;&nbsp;</a></span>createPipeline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RenderSystem::createPipeline </td>
          <td>(</td>
          <td class="paramtype">VkPipeline &amp;&#160;</td>
          <td class="paramname"><em>pipeline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPipelineLayout &amp;&#160;</td>
          <td class="paramname"><em>pipelineLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDescriptorSetLayout &amp;&#160;</td>
          <td class="paramname"><em>descriptorSetLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; VkPipelineShaderStageCreateInfo &gt; &amp;&#160;</td>
          <td class="paramname"><em>shaderStages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkRenderPass &amp;&#160;</td>
          <td class="paramname"><em>renderPass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new pipeline. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipeline</td><td>The pipeline to create </td></tr>
    <tr><td class="paramname">pipelineLayout</td><td>The layout for the pipeline, created in this method </td></tr>
    <tr><td class="paramname">descriptorSetLayout</td><td>Descripes Which types of resources the pipeline should expect as inputs for the shaders </td></tr>
    <tr><td class="paramname">shaderStages</td><td>The shaders that the pipline will use </td></tr>
    <tr><td class="paramname">renderPass</td><td>The renderPass the pipeline will use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa90bf882e4c3136ee272a1733eb38291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90bf882e4c3136ee272a1733eb38291">&#9670;&nbsp;</a></span>createRenderable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RenderSystem::createRenderable </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_renderable.html">Renderable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renderable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="class_renderable.html" title="A Class for representing objects that are rendered in the scene.">Renderable</a> object. </p>
<p>Very simple - Just creates a renderable shared_ptr, passing the <a class="el" href="class_vulkan_context.html" title="Contains primary Vulkan constructs that remain constant throughout the a uwb-vk application.">VulkanContext</a> in its constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderable</td><td>The renderable object to create </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0558495d4560e36e338336645f34153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0558495d4560e36e338336645f34153">&#9670;&nbsp;</a></span>createShader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RenderSystem::createShader </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_shader.html">Shader</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>shader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkShaderStageFlagBits&#160;</td>
          <td class="paramname"><em>stage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="class_shader.html" title="A Single Shader module and shader stage create info.">Shader</a> object. </p>
<p>Creates a <a class="el" href="class_shader.html" title="A Single Shader module and shader stage create info.">Shader</a> object with std::make_shared and keeps a copy to properly cleanup at the end</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shader</td><td>The shader object to create </td></tr>
    <tr><td class="paramname">filename</td><td>The shader file to load (must a *.spv file) </td></tr>
    <tr><td class="paramname">stage</td><td>The shader stage the shader will run in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c31fab93f511b2103917679ccc52f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c31fab93f511b2103917679ccc52f6d">&#9670;&nbsp;</a></span>createShadowFramebuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RenderSystem::createShadowFramebuffers </td>
          <td>(</td>
          <td class="paramtype">VkRenderPass&#160;</td>
          <td class="paramname"><em>shadowRenderPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageView&#160;</td>
          <td class="paramname"><em>shadowImageView</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the FrameBuffers used as the output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shadowRenderPass</td><td>The VkRenderPass describing attachments </td></tr>
    <tr><td class="paramname">shadowImageView</td><td>The VkImageView object for the shadow map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c7bcbc69bc3e34c5cccd42a5a1ddf91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c7bcbc69bc3e34c5cccd42a5a1ddf91">&#9670;&nbsp;</a></span>createShadowRenderPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RenderSystem::createShadowRenderPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_shadow_map.html">ShadowMap</a> &amp;&#160;</td>
          <td class="paramname"><em>shadowMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a RenderPass for writing to the <a class="el" href="struct_shadow_map.html" title="A ShadowMap.">ShadowMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shadowMap</td><td>The <a class="el" href="struct_shadow_map.html" title="A ShadowMap.">ShadowMap</a> the renderpass will write to when running </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afae24ad1ef810abc7a16ca331f4e6eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae24ad1ef810abc7a16ca331f4e6eef">&#9670;&nbsp;</a></span>createTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RenderSystem::createTexture </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="class_texture.html" title="A class for holding the information loaded from texture files.">Texture</a> object. </p>
<p>Creates a <a class="el" href="class_texture.html" title="A class for holding the information loaded from texture files.">Texture</a> object with std::make_shared and keeps a copy to properly cleanup at the end</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The texture object to create </td></tr>
    <tr><td class="paramname">filename</td><td>A directory to the image file to create the texture from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43e41f536fee8a17796034acaeafb6e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e41f536fee8a17796034acaeafb6e9">&#9670;&nbsp;</a></span>createUniformBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RenderSystem::createUniformBuffer </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="struct_u_b_o.html">UBO</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ubo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a Uniform Buffer Object. </p>
<p>Note: the count parameter is untested and likely does not work, so leave at one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ubo</td><td>The Uniform Buffer Object to create </td></tr>
    <tr><td class="paramname">count</td><td>the number of UBOs to create </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b91a5694d7220da53c8826155f6470d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b91a5694d7220da53c8826155f6470d">&#9670;&nbsp;</a></span>drawRenderable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RenderSystem::drawRenderable </td>
          <td>(</td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_renderable.html">Renderable</a> &gt;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDescriptorSet &amp;&#160;</td>
          <td class="paramname"><em>descriptorSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a renderable object. </p>
<p>Draw a renderable object. This method should be called during command buffer construction</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>A commandBuffer that is in the middle of recording </td></tr>
    <tr><td class="paramname">model</td><td>A renderable object ready to be rendered </td></tr>
    <tr><td class="paramname">descriptorSet</td><td>A descriptor set for binding the required resources for the draw command </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f0624e2d58d21719611ce863eafb031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0624e2d58d21719611ce863eafb031">&#9670;&nbsp;</a></span>getShadowMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_shadow_map.html">ShadowMap</a> RenderSystem::getShadowMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="struct_shadow_map.html" title="A ShadowMap.">ShadowMap</a>. </p>
<p>This is commonly used to set a <a class="el" href="class_renderable.html" title="A Class for representing objects that are rendered in the scene.">Renderable</a> as shadow-receiving </p>

</div>
</div>
<a id="aeaee982760399e62180207c573a469e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaee982760399e62180207c573a469e7">&#9670;&nbsp;</a></span>instantiateRenderable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RenderSystem::instantiateRenderable </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_renderable.html">Renderable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renderable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiate a renderable that has been set up. </p>
<p>Instaniates a renderable by creating the Descriptor Set Layouts, DescriptorSets, and Pipelines. Also keeps a copy of the renderable for cleanup, and recreates the command buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderable</td><td>The <a class="el" href="class_renderable.html" title="A Class for representing objects that are rendered in the scene.">Renderable</a> to instantiate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab24aff4914313ebaa5d87633d2126b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24aff4914313ebaa5d87633d2126b6d">&#9670;&nbsp;</a></span>recreateSwapchain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RenderSystem::recreateSwapchain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recreate the <a class="el" href="class_swapchain.html" title="A swapchain of images the Render System draws to the screen with.">Swapchain</a>. </p>
<p>If large changes to the <a class="el" href="class_render_system.html" title="Primary class responsible for rendering operations.">RenderSystem</a> are made (such as changing the clear color), the swapchain will need to be recreated with the new settings through this method </p>

</div>
</div>
<a id="a3d3fc11d70c1b8da1178cd6f5f647c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3fc11d70c1b8da1178cd6f5f647c74">&#9670;&nbsp;</a></span>setClearColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RenderSystem::setClearColor </td>
          <td>(</td>
          <td class="paramtype">VkClearValue&#160;</td>
          <td class="paramname"><em>clearColor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the background clear color to a given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clearColor</td><td>The Color to set the background color as </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad31d7e4c0a7b37fd101f3b5c13dbe12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad31d7e4c0a7b37fd101f3b5c13dbe12">&#9670;&nbsp;</a></span>setLightMVPBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RenderSystem::setLightMVPBuffer </td>
          <td>(</td>
          <td class="paramtype">const glm::mat4 &amp;&#160;</td>
          <td class="paramname"><em>mvp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the MVP buffer for a shadow-casting light source. </p>
<p>Set the MVP buffer for a shadow-casting light source. Currently This only supports a single light source, but could be modified to support several</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mvp</td><td>The mvp matrix to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c3025bd7da582aef27ba42bb4f32de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c3025bd7da582aef27ba42bb4f32de9">&#9670;&nbsp;</a></span>updateUniformBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RenderSystem::updateUniformBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_u_b_o.html">UBO</a> &amp;&#160;</td>
          <td class="paramname"><em>ubo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>uboData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the info inside a <a class="el" href="struct_u_b_o.html" title="A Uniform Buffer Object for sending data to shaders.">UBO</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ubo</td><td>The <a class="el" href="struct_u_b_o.html" title="A Uniform Buffer Object for sending data to shaders.">UBO</a> to update </td></tr>
    <tr><td class="paramname">uboData</td><td>The data to update the <a class="el" href="struct_u_b_o.html" title="A Uniform Buffer Object for sending data to shaders.">UBO</a> with </td></tr>
    <tr><td class="paramname">bufIndex</td><td>If the <a class="el" href="struct_u_b_o.html" title="A Uniform Buffer Object for sending data to shaders.">UBO</a> is an array, this provides an index within the array to update at. NoteL this feature is untested and likely does not work. Please leave at 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_render_system_8h_source.html">RenderSystem.h</a></li>
<li>src/RenderSystem.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_render_system.html">RenderSystem</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
